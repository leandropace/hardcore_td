<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Batalha dos Boletos</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    body { background:#f3f4f6; font-family:'Inter',sans-serif; overflow:hidden; }
    canvas { cursor:pointer; border-radius:0.75rem;
      box-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
    .ui-panel { background:#fff; border-radius:0.75rem;
      box-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }
    .tower-card.selected, .tower-card:hover { border-color:#3b82f6; background:#eff6ff; }
    .tower-card { transition:all .2s ease-in-out; border:2px solid transparent; }
    .modal { transition:opacity .3s ease, transform .3s ease; }
    .modal-hidden { opacity:0; transform:scale(.95); pointer-events:none; }
    .tower-card-img { width:48px; height:48px; background-size:contain; background-position:center; background-repeat:no-repeat; }
    .tooltip { position: absolute; background: #fff; border: 1px solid #ccc; padding: 8px; border-radius: 4px; display: none; z-index: 10; }
    .progress-bar { background: #e5e7eb; height: 8px; border-radius: 4px; margin-top: 8px; }
    .progress-fill { background: #10b981; height: 100%; border-radius: 4px; transition: width 0.3s; }
  </style>
</head>
<body class="flex flex-col xl:flex-row items-center justify-center min-h-screen p-4 gap-4">
  <!-- Painel -->
  <div class="ui-panel w-full xl:w-96 p-5 flex-shrink-0 order-2 xl:order-1 self-stretch flex flex-col">
    <h1 class="text-3xl font-bold text-gray-800 text-center mb-4">BATALHA DOS BOLETOS</h1>
    <div class="grid grid-cols-3 gap-3 text-center mb-4">
      <div class="bg-gray-100 p-2 rounded-lg">
        <div class="text-sm font-semibold text-emerald-600">üí∞ Saldo</div>
        <div id="staples-amount" class="text-xl font-bold text-gray-800">200</div>
      </div>
      <div class="bg-gray-100 p-2 rounded-lg">
        <div class="text-sm font-semibold text-rose-500">‚ù§Ô∏è Serenidade</div>
        <div id="health-amount" class="text-xl font-bold text-rose-600">20</div>
      </div>
      <div class="bg-gray-100 p-2 rounded-lg">
        <div class="text-sm font-semibold text-blue-500">üìÜ Etapa</div>
        <div id="wave-number" class="text-xl font-bold text-blue-600">0</div>
      </div>
    </div>
    <!-- Progresso da Etapa -->
    <div id="wave-progress" class="progress-bar">
      <div id="progress-fill" class="progress-fill" style="width: 0%;"></div>
    </div>
    <!-- Loja -->
    <div id="tower-shop">
      <h2 class="text-lg font-semibold text-gray-700 mb-2">Ferramentas Financeiras</h2>
      <div id="tower-selection" class="space-y-2"></div>
    </div>
    <!-- Upgrade -->
    <div id="upgrade-panel" class="hidden mt-4 pt-4 border-t">
      <h2 id="upgrade-tower-name" class="text-lg font-semibold text-gray-700 mb-2"></h2>
      <p class="text-sm text-gray-500 mb-2">N√≠vel: <span id="upgrade-tower-level"></span></p>
      <p class="text-sm text-gray-500 mb-3">Dano: <span id="upgrade-tower-damage"></span> | Alcance: <span id="upgrade-tower-range"></span></p>
      <button id="upgrade-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition"></button>
      <button id="sell-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition mt-2"></button>
    </div>
    <div class="flex-grow"></div>
    <div class="flex gap-2 mt-4">
      <button id="start-wave-btn" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white text-xl font-bold py-3 rounded-lg shadow-md transition-transform transform hover:scale-105">INICIAR ETAPA</button>
      <div class="flex-shrink-0 flex gap-2">
        <button id="pause-btn" class="w-12 bg-gray-500 hover:bg-gray-600 text-white text-2xl font-bold py-3 rounded-lg shadow-md" disabled>‚è∏Ô∏è</button>
        <button id="speed-btn" class="w-12 bg-indigo-500 hover:bg-indigo-600 text-white text-xl font-bold py-3 rounded-lg shadow-md">1x</button>
        <button id="mute-btn" class="w-12 bg-yellow-500 hover:bg-yellow-600 text-white text-2xl font-bold py-3 rounded-lg shadow-md">üîä</button>
      </div>
    </div>
  </div>

  <!-- Jogo -->
  <div class="relative order-1 xl:order-2">
    <canvas id="gameCanvas" width="880" height="640"></canvas>
    <div id="modal" class="modal modal-hidden absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-white text-center p-8 rounded-lg">
      <h2 id="modal-title" class="text-5xl font-bold mb-4"></h2>
      <div id="modal-content" class="text-lg mb-6 whitespace-pre-wrap"></div>
      <div id="modal-buttons"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgCanvas = document.createElement('canvas');
    const bgCtx = bgCanvas.getContext('2d');
    bgCanvas.width = canvas.width; bgCanvas.height = canvas.height;

    const ASSETS = { towers:{}, enemies:{} };
    const audio = {
      ready:false, muted:false, synths:{}, music:null,
      lastHitSoundTime:0, hitSoundInterval:0.05,
      lastShootSoundTime:0, shootSoundInterval:0.05
    };

    const TILE_SIZE=40;
    const TOWER_RADIUS = TILE_SIZE/2 - 2;
    const MAX_PROJECTILES = 200;

    function createSvgImage(svg){ const img=new Image(); img.src='data:image/svg+xml;base64,'+btoa(svg); return img; }
    function clamp(v,min,max){ return v<min?min: v>max?max: v; }
    function pointSegmentDistance(x,y,x1,y1,x2,y2){
      const A=x-x1, B=y-y1, C=x2-x1, D=y2-y1;
      const dot=A*C+B*D, len=C*C+D*D;
      let t = len ? dot/len : -1; t = t<0?0: t>1?1:t;
      const xx=x1+t*C, yy=y1+t*D; const dx=x-xx, dy=y-yy; return Math.hypot(dx,dy);
    }

    // ========= THEME: VIDA FINANCEIRA =========
    function defineAssets(){
      // Towers: cofrinho, planilha, freela, guarda_chuva, fundo
      ASSETS.towers.cofrinho = [
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><ellipse rx="15" ry="12" fill="#f59e0b"/><circle cx="7" cy="-2" r="3" fill="#fff"/><circle cx="7" cy="-2" r="1.2" fill="#1f2937"/><rect x="-6" y="-13" width="12" height="3" rx="1" fill="#78350f"/><circle cx="-11" cy="-3" r="3" fill="#f59e0b"/><path d="M-11 -3 q -4 4 0 8" stroke="#d97706" stroke-width="2" fill="none"/></g></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><ellipse rx="16" ry="13" fill="#f59e0b"/><rect x="-7" y="-14" width="14" height="3" rx="1" fill="#6b21a8"/><circle cx="8" cy="-2" r="3.2" fill="#fff"/><circle cx="8" cy="-2" r="1.3" fill="#111827"/><circle cx="-12" cy="-2" r="3.2" fill="#f59e0b"/><path d="M-12 -2 q -5 5 0 9" stroke="#d97706" stroke-width="2" fill="none"/></g></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><ellipse rx="17.5" ry="14" fill="#ea580c"/><rect x="-8" y="-15" width="16" height="3.5" rx="1" fill="#3b82f6"/><circle cx="9" cy="-2" r="3.4" fill="#fff"/><circle cx="9" cy="-2" r="1.4" fill="#000"/><circle cx="-13" cy="-1.5" r="3.4" fill="#ea580c"/><path d="M-13 -1.5 q -5.5 5.5 0 10" stroke="#9a3412" stroke-width="2" fill="none"/></g></svg>`)
      ];
      ASSETS.towers.planilha = [
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="6" width="24" height="28" rx="3" fill="#e5f3ff" stroke="#60a5fa" /><g stroke="#93c5fd"><line x1="12" y1="10" x2="28" y2="10"/><line x1="12" y1="16" x2="28" y2="16"/><line x1="12" y1="22" x2="28" y2="22"/><line x1="12" y1="28" x2="28" y2="28"/><line x1="16" y1="10" x2="16" y2="34"/><line x1="22" y1="10" x2="22" y2="34"/></g></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="7" y="5" width="26" height="30" rx="4" fill="#dbeafe" stroke="#3b82f6" /><g stroke="#60a5fa" stroke-width="1.3"><line x1="12" y1="11" x2="28" y2="11"/><line x1="12" y1="17" x2="28" y2="17"/><line x1="12" y1="23" x2="28" y2="23"/><line x1="12" y1="29" x2="28" y2="29"/><line x1="16" y1="11" x2="16" y2="33"/><line x1="22" y1="11" x2="22" y2="33"/></g><circle cx="30" cy="9" r="3" fill="#22c55e"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="28" height="32" rx="5" fill="#bfdbfe" stroke="#2563eb" /><g stroke="#3b82f6" stroke-width="1.4"><line x1="12" y1="12" x2="28" y2="12"/><line x1="12" y1="18" x2="28" y2="18"/><line x1="12" y1="24" x2="28" y2="24"/><line x1="12" y1="30" x2="28" y2="30"/><line x1="16" y1="12" x2="16" y2="34"/><line x1="22" y1="12" x2="22" y2="34"/></g><path d="M10 8 L14 4 L18 8" fill="#22c55e"/></svg>`)
      ];
      ASSETS.towers.freela = [
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="12" width="24" height="16" rx="3" fill="#9ca3af"/><rect x="14" y="8" width="12" height="6" rx="2" fill="#6b7280"/><circle cx="28" cy="20" r="3" fill="#22c55e"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="7" y="11" width="26" height="18" rx="4" fill="#6b7280"/><rect x="13" y="7" width="14" height="7" rx="2.5" fill="#4b5563"/><circle cx="29" cy="20" r="3.4" fill="#16a34a"/><circle cx="24" cy="20" r="2" fill="#16a34a"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="10" width="28" height="20" rx="5" fill="#374151"/><rect x="12" y="6" width="16" height="8" rx="3" fill="#1f2937"/><circle cx="30" cy="20" r="3.8" fill="#10b981"/><circle cx="25" cy="20" r="2.4" fill="#10b981"/><circle cx="20" cy="20" r="1.6" fill="#10b981"/></svg>`)
      ];
      ASSETS.towers.guarda_chuva = [
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M5 18 C12 8, 28 8, 35 18" fill="#60a5fa"/><rect x="19" y="18" width="2" height="14" fill="#0ea5e9"/><path d="M21 32 q3 3 0 6" stroke="#0ea5e9" stroke-width="2" fill="none"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M4 18 C12 6, 28 6, 36 18" fill="#3b82f6"/><rect x="19" y="18" width="2.2" height="15" fill="#2563eb"/><path d="M21 33 q3 3 0 6" stroke="#2563eb" stroke-width="2.2" fill="none"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M3 18 C12 4, 28 4, 37 18" fill="#1d4ed8"/><rect x="19" y="18" width="2.4" height="16" fill="#1e40af"/><path d="M21 34 q3 3 0 6" stroke="#1e40af" stroke-width="2.4" fill="none"/></svg>`)
      ];
      ASSETS.towers.fundo = [
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="24" height="24" rx="4" fill="#111827"/><polyline points="10,26 16,22 21,24 28,14 30,16" fill="none" stroke="#22c55e" stroke-width="2"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="7" y="7" width="26" height="26" rx="5" fill="#0b1220"/><polyline points="10,26 16,21 22,25 29,13 32,16" fill="none" stroke="#10b981" stroke-width="2.4"/></svg>`),
        createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="6" width="28" height="28" rx="6" fill="#020617"/><polyline points="10,26 16,20 22,24 30,12 34,16" fill="none" stroke="#34d399" stroke-width="2.6"/></svg>`)
      ];

      // Enemies: gastinho, impulso, boleto, juros, inflacao, golpe, boss
      ASSETS.enemies.gastinho = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" fill="#fbbf24"/><path d="M8 12h8M12 8v8" stroke="#1f2937" stroke-width="1.5"/></svg>');
      ASSETS.enemies.impulso  = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="16" height="16" rx="3" fill="#ef4444"/><path d="M12 6 v8" stroke="#fff" stroke-width="2"/><circle cx="12" cy="16" r="1.6" fill="#fff"/></svg>');
      ASSETS.enemies.boleto   = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="3" width="14" height="18" rx="2" fill="#e5e7eb" stroke="#6b7280"/><g stroke="#9ca3af" stroke-width="1"><line x1="7" y1="8" x2="17" y2="8"/><line x1="7" y1="11" x2="17" y2="11"/><line x1="7" y1="14" x2="17" y2="14"/></g></svg>');
      ASSETS.enemies.juros    = createSvgImage('<svg viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg"><circle cx="14" cy="14" r="12" fill="#7c3aed"/><path d="M9 19 L19 9" stroke="#fff" stroke-width="2"/><circle cx="10.5" cy="17.5" r="1.7" fill="#fff"/><circle cx="17.5" cy="10.5" r="1.7" fill="#fff"/></svg>');
      ASSETS.enemies.inflacao = createSvgImage('<svg viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg"><circle cx="14" cy="14" r="12" fill="#f97316"/><path d="M8 15 q4-8 12-4" stroke="#fff" stroke-width="2" fill="none"/><path d="M18 9 l4 2 -3 3" fill="#fff"/></svg>');
      ASSETS.enemies.golpe    = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="3" width="18" height="18" fill="#14b8a6"/><rect x="6" y="9" width="4" height="6" fill="#000"/><rect x="14" y="9" width="4" height="6" fill="#000"/></svg>');
      ASSETS.enemies.boss     = createSvgImage('<svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><circle cx="25" cy="25" r="22" fill="#be123c"/><path d="M15 15 L22 25 L15 35 M35 15 L28 25 L35 35" stroke="#fff" stroke-width="4" fill="none"/><circle cx="25" cy="25" r="5" fill="#fca5a5"/><circle cx="25" cy="25" r="2" fill="#991b1b"/></svg>');
    }

    function preloadAssets(cb){
      const list=[]; for (const t in ASSETS.towers) ASSETS.towers[t].forEach(i=>list.push(i)); for (const e in ASSETS.enemies) list.push(ASSETS.enemies[e]);
      if (!list.length) return cb();
      let n=0; const done=()=>{ if (++n===list.length) cb(); };
      list.forEach(img=>{ if (img.complete && img.naturalHeight!==0) done(); else { img.onload=done; img.onerror=done; }});
    }

    // ========= SETTINGS =========
    const DIFFICULTY_SETTINGS={
      facil :{ startingStaples:260, startingHealth:26, enemyHealthMultiplier:0.86, towerCostMultiplier:0.92 },
      normal:{ startingStaples:200, startingHealth:20, enemyHealthMultiplier:1.0,  towerCostMultiplier:1.0  },
      dificil:{ startingStaples:150, startingHealth:16, enemyHealthMultiplier:1.15, towerCostMultiplier:1.12 },
    };
    const SPEED_MULTIPLIERS=[1,2,4];

    const TOWER_SPECS={
      cofrinho:{ name:'Cofrinho', baseCost:15, unlocksAtMap:0, upgrades:[
        { cost:18, damage:7, range:90,  fireRate:22, projectile:{speed:6, size:3, color:'#f59e0b'} },
        { cost:35, damage:13, range:100, fireRate:18, projectile:{speed:6, size:4, color:'#ea580c'} },
        { cost:70, damage:22, range:110, fireRate:14, projectile:{speed:7, size:5, color:'#9a3412'} },
      ]},
      planilha:{ name:'Planilha', baseCost:55, unlocksAtMap:0, upgrades:[
        { cost:70, range:120, fireRate:150, slow:{factor:0.55, duration:120}, projectile:{speed:4, size:8, color:'#bfdbfe'} },
        { cost:120, range:130, fireRate:140, slow:{factor:0.45, duration:150}, projectile:{speed:4, size:9, color:'#93c5fd'} },
        { cost:200, range:140, fireRate:130, slow:{factor:0.35, duration:180}, projectile:{speed:4, size:10, color:'#60a5fa'} },
      ]},
      freela:{ name:'Freela', baseCost:45, unlocksAtMap:1, upgrades:[
        { cost:55, damage:16, range:100, fireRate:50, burst:3, projectile:{speed:7, size:4, color:'#10b981'} },
        { cost:100, damage:26, range:110, fireRate:45, burst:3, projectile:{speed:7, size:5, color:'#059669'} },
        { cost:175, damage:40, range:120, fireRate:40, burst:4, projectile:{speed:8, size:5, color:'#047857'} },
      ]},
      guarda_chuva:{ name:'Guarda‚ÄëChuva', baseCost:80, unlocksAtMap:5, upgrades:[
        { cost:90,  damage:12, range:115, fireRate:90, splash:32, projectile:{speed:5, size:6, color:'#60a5fa'} },
        { cost:160, damage:20, range:125, fireRate:85, splash:36, projectile:{speed:5, size:7, color:'#3b82f6'} },
        { cost:260, damage:30, range:135, fireRate:80, splash:40, projectile:{speed:6, size:8, color:'#1d4ed8'} },
      ]},
      fundo:{ name:'Fundo Indexado', baseCost:130, unlocksAtMap:3, upgrades:[
        { cost:160, damage:100, range:260, fireRate:220, projectile:{speed:10, size:6, color:'#22c55e'} },
        { cost:260, damage:210, range:290, fireRate:200, projectile:{speed:10, size:7, color:'#10b981'} },
        { cost:420, damage:420, range:320, fireRate:185, projectile:{speed:12, size:8, color:'#34d399'} },
      ]},
    };

    const ENEMY_SPECS={
      gastinho:{ health:35,  speed:2.2, size:10, staples:1 },
      impulso :{ health:22,  speed:3.0, size:9,  staples:1 },
      boleto  :{ health:80,  speed:1.2, size:14, staples:2 },
      juros   :{ health:160, speed:0.9, size:16, staples:4 },
      inflacao:{ health:120, speed:1.5, size:12, staples:3 },
      golpe   :{ health:55,  speed:2.2, size:11, staples:3 },
      boss    :{ health:2200, speed:0.8, size:24, staples:25 },
    };

    // Life stage maps & paths
    const MAPS = [
      { name:'Inf√¢ncia (Quarto)', path:[{x:0,y:4},{x:5,y:4},{x:5,y:11},{x:15,y:11},{x:15,y:2},{x:22,y:2}] },
      { name:'Adolesc√™ncia (Bairro)', path:[{x:0,y:8},{x:3,y:8},{x:3,y:2},{x:9,y:2},{x:9,y:13},{x:3,y:13},{x:3,y:10},{x:17,y:10},{x:17,y:4},{x:22,y:4}] },
      { name:'Faculdade (Campus)', path:[{x:3,y:0},{x:3,y:5},{x:12,y:5},{x:12,y:2},{x:18,y:2},{x:18,y:8},{x:8,y:8},{x:8,y:13},{x:18,y:13},{x:18,y:16}] },
      { name:'Rep√∫blica (Aluguel)', path:[{x:0,y:2},{x:18,y:2},{x:18,y:13},{x:2,y:13},{x:2,y:6},{x:22,y:6}] },
      { name:'Primeiro Emprego (Centro)', path:[{x:0,y:8},{x:22,y:8}] },
      { name:'Vida a Dois (Apto)', path:[{x:11,y:0},{x:11,y:5},{x:2,y:5},{x:2,y:11},{x:20,y:11},{x:20,y:2},{x:15,y:2},{x:15,y:16}] },
      { name:'Pais de Primeira Viagem', path:[{x:0,y:13},{x:5,y:13},{x:5,y:2},{x:17,y:2},{x:17,y:13},{x:22,y:13}] },
      { name:'Hipoteca (Sub√∫rbio)', path:[{x:0,y:1},{x:2,y:1},{x:2,y:14},{x:5,y:14},{x:5,y:3},{x:8,y:3},{x:8,y:14},{x:11,y:14},{x:11,y:1},{x:22,y:1}] },
      { name:'Crise & Juros Altos', path:[{x:2,y:0},{x:2,y:13},{x:20,y:13},{x:20,y:2},{x:8,y:2},{x:8,y:8},{x:22,y:8}] },
      { name:'Aposentadoria (Praia)', path:[{x:0,y:8},{x:5,y:8},{x:5,y:3},{x:16,y:3},{x:16,y:12},{x:5,y:12},{x:5,y:16}] }
    ];

    const PATH_STYLES = {
      default: { base: 'rgba(0,0,0,0.05)', inner: 'rgba(0,0,0,0.12)', glow: 0, arrows: false, arrowColor: '' },
      4: { base: 'rgba(255,255,255,0.14)', inner: 'rgba(255,255,255,0.38)', glow: 10, arrows: true, arrowColor: 'rgba(255,255,255,0.85)' },
      9: { base: 'rgba(255,255,255,0.16)', inner: 'rgba(255,255,255,0.5)', glow: 8, arrows: true, arrowColor: 'rgba(255,255,255,0.9)' }
    };

    // Stage flavor (boss labels for the modal)
    const STAGE_BOSSES = [
      'Bicicleta Nova',
      'Primeiro Smartphone',
      'Mensalidade da Faculdade',
      'Mudan√ßa de Cidade',
      'Carro Usado',
      'Casamento & Festa',
      'Chegada do Beb√™',
      'Entrada da Casa',
      'Crise Econ√¥mica',
      'Aposentadoria Tranquila'
    ];

    // Generate 50 waves tuned to life stages
    const WAVES = generateWaves();

    function generateWaves(){
      const waves=[];
      for(let stage=0; stage<10; stage++){
        for(let w=0; w<5; w++){
          const i = stage*5 + w; // 0..49
          const obj = { enemies: [] };
          const difficultyBump = stage * 0.1 + w*0.02;

          // base counts scale up
          const base = 6 + i*2;
          const add = (type, count, delay) => obj.enemies.push({type, count: Math.max(1, Math.floor(count)), delay});

          // stage composition
          if (stage === 0){ // Inf√¢ncia
            add('gastinho', base, 45 - w*3);
            add('impulso',  Math.max(0, base*0.4), 70 - w*4);
          } else if (stage === 1){ // Adolesc√™ncia
            add('gastinho', base*0.7, 40);
            add('impulso',  base*0.7, 60);
            add('boleto',   base*0.2, 120);
          } else if (stage === 2){ // Faculdade
            add('boleto',   base*0.7, 70);
            add('impulso',  base*0.5, 55);
            add('juros',    base*0.15, 140);
          } else if (stage === 3){ // Rep√∫blica
            add('boleto',   base*0.8, 60);
            add('juros',    base*0.25, 130);
          } else if (stage === 4){ // Primeiro Emprego
            add('gastinho', base*0.6, 45);
            add('boleto',   base*0.7, 60);
            add('juros',    base*0.3, 120);
          } else if (stage === 5){ // Vida a Dois
            add('boleto',   base*0.8, 55);
            add('juros',    base*0.35, 110);
            add('impulso',  base*0.45, 65);
          } else if (stage === 6){ // Pais de Primeira Viagem
            add('boleto',   base*0.9, 55);
            add('juros',    base*0.35, 110);
            add('inflacao', base*0.25, 120);
          } else if (stage === 7){ // Hipoteca
            add('boleto',   base*1.0, 50);
            add('juros',    base*0.45, 100);
            add('inflacao', base*0.35, 110);
          } else if (stage === 8){ // Crise & Juros Altos
            add('juros',    base*0.7, 100);
            add('inflacao', base*0.6, 100);
            add('golpe',    base*0.35, 80);
          } else { // Aposentadoria
            add('gastinho', base*0.5, 55);
            add('juros',    base*0.6, 100);
            add('inflacao', base*0.5, 110);
            add('golpe',    base*0.3, 90);
          }

          // boss every 5th wave
          if (w === 4){
            add('boss', 1 + Math.floor(stage/2), 200);
          }

          waves.push(obj);
        }
      }
      return waves;
    }

    // ========= GAME STATE =========
    let gameState = {
      staples:200, health:20, wave:0, mapIndex:0, status:'START',
      enemies:[], towers:[], projectiles:[],
      selectedTowerToPlace:null, selectedPlacedTower:null,
      waveInProgress:false, mouse:{x:0,y:0,down:false},
      currentWave:null, spawnTimer:0, spawnIndex:0,
      waveEndTimer:null, waveEndCountdown:10,
      difficulty:null, gameSpeed:1, speedIndex:0,
      totalEnemiesToSpawn:0, spawnedEnemies:0
    };

    // ========= UI ELEMENTS =========
    const staplesEl=document.getElementById('staples-amount');
    const healthEl=document.getElementById('health-amount');
    const waveEl=document.getElementById('wave-number');
    const startWaveBtn=document.getElementById('start-wave-btn');
    const towerSelectionEl=document.getElementById('tower-selection');
    const upgradePanelEl=document.getElementById('upgrade-panel');
    const upgradeTowerNameEl=document.getElementById('upgrade-tower-name');
    const upgradeTowerLevelEl=document.getElementById('upgrade-tower-level');
    const upgradeTowerDamageEl=document.getElementById('upgrade-tower-damage');
    const upgradeTowerRangeEl=document.getElementById('upgrade-tower-range');
    const upgradeBtn=document.getElementById('upgrade-btn');
    const sellBtn=document.getElementById('sell-btn');
    const pauseBtn=document.getElementById('pause-btn');
    const speedBtn=document.getElementById('speed-btn');
    const muteBtn=document.getElementById('mute-btn');
    const progressFill = document.getElementById('progress-fill');

    // Spatial index
    const CELL_SIZE = 80;
    const GRID_COLS = Math.ceil(canvas.width / CELL_SIZE);
    const GRID_ROWS = Math.ceil(canvas.height / CELL_SIZE);
    const gridCells = Array.from({length: GRID_COLS * GRID_ROWS}, () => []);
    function resetGrid(){ for (let i=0;i<gridCells.length;i++) gridCells[i].length=0; }
    function cellIndexFor(x,y){ const cx = clamp(Math.floor(x / CELL_SIZE), 0, GRID_COLS-1); const cy = clamp(Math.floor(y / CELL_SIZE), 0, GRID_ROWS-1); return cy*GRID_COLS + cx; }
    function addEnemyToGrid(e){ gridCells[cellIndexFor(e.x, e.y)].push(e); }
    function forEachEnemyNearCircle(x, y, r, cb){
      const minC = clamp(Math.floor((x - r)/CELL_SIZE), 0, GRID_COLS-1);
      const maxC = clamp(Math.floor((x + r)/CELL_SIZE), 0, GRID_COLS-1);
      const minR = clamp(Math.floor((y - r)/CELL_SIZE), 0, GRID_ROWS-1);
      const maxR = clamp(Math.floor((y + r)/CELL_SIZE), 0, GRID_ROWS-1);
      for (let cy=minR; cy<=maxR; cy++){
        for (let cx=minC; cx<=maxC; cx++){
          const arr = gridCells[cy*GRID_COLS + cx];
          for (let i=0;i<arr.length;i++) cb(arr[i]);
        }
      }
    }

    // ========= ENTITIES =========
    class Enemy {
      constructor(type){
        const start = MAPS[gameState.mapIndex].path[0];
        this.x = start.x*TILE_SIZE + TILE_SIZE/2;
        this.y = start.y*TILE_SIZE + TILE_SIZE/2;
        this.pathIndex = 0;
        this.type = type;
        this.spec = ENEMY_SPECS[type];
        this.health = this.spec.health * (1 + (gameState.wave * 0.05)) * gameState.difficulty.enemyHealthMultiplier;
        this.maxHealth = this.health;
        this.baseSpeed = this.spec.speed;
        this.speed = this.baseSpeed;
        this.size = this.spec.size;
        this.slowTimer=0; this.glitchTimer=0;
      }
      update(){
        if (this.slowTimer>0) this.slowTimer--;
        else this.speed = this.baseSpeed;
        const path = MAPS[gameState.mapIndex].path;
        let remaining = this.speed;
        while (remaining > 0) {
          if (this.pathIndex >= path.length - 1) {
            gameState.health--; playSound('error','A2'); return false;
          }
          const tgt = path[this.pathIndex+1];
          const tx = tgt.x*TILE_SIZE + TILE_SIZE/2;
          const ty = tgt.y*TILE_SIZE + TILE_SIZE/2;
          const dx = tx - this.x;
          const dy = ty - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist === 0) {
            this.pathIndex++;
            continue;
          }
          if (remaining >= dist) {
            this.x = tx; this.y = ty;
            remaining -= dist;
            this.pathIndex++;
          } else {
            this.x += (dx/dist) * remaining;
            this.y += (dy/dist) * remaining;
            remaining = 0;
          }
        }
        return true;
      }
      draw(){
        const img=ASSETS.enemies[this.type];
        // "Golpe" flickers like a scam popping in/out
        if (this.type==='golpe'){ this.glitchTimer=(this.glitchTimer+1)%20; if (this.glitchTimer<10) return; }
        if (img && img.complete){
          const s=this.size*2.2; ctx.drawImage(img, this.x-s/2, this.y-s/2, s, s);
        }
        const pct=this.health/this.maxHealth;
        ctx.fillStyle='#dc2626'; ctx.fillRect(this.x-this.size, this.y-this.size-8, this.size*2, 4);
        ctx.fillStyle='#22c55e'; ctx.fillRect(this.x-this.size, this.y-this.size-8, this.size*2*pct, 4);
      }
      takeDamage(v){
        this.health -= v;
        if (v>0) {
          playSound('hit','G2','32n');
          for (let i=0; i<5; i++) {
            gameState.projectiles.push(new Particle(this.x, this.y, Math.random()*Math.PI*2, 2+Math.random()*3, '#ef4444'));
          }
        }
        if (this.health<=0){ gameState.staples += this.spec.staples; return false; }
        return true;
      }
    }

    class Tower {
      constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.level=0; this.spec=TOWER_SPECS[type];
        this.target=null; this.fireCooldown=0; this.burstCooldown=0; this.burstCount=0; this.rotation=0; this.targetCooldown=0; }
      getStats(){ return this.spec.upgrades[this.level]; }
      update(){
        if (this.fireCooldown>0) this.fireCooldown--;
        if (this.targetCooldown>0) this.targetCooldown--;
        else { this.findTarget(); this.targetCooldown=5; }
        if (this.target){
          const dx=this.target.x-this.x, dy=this.target.y-this.y;
          this.rotation = Math.atan2(dy, dx);
          if (this.fireCooldown<=0){
            if (this.getStats().burst){ this.burstCount=this.getStats().burst; this.burstCooldown=5; }
            else this.shoot();
            this.fireCooldown = this.getStats().fireRate;
          }
        }
        if (this.burstCount>0){
          if (this.burstCooldown>0) this.burstCooldown--;
          else { this.shoot(); this.burstCount--; this.burstCooldown=5; }
        }
      }
      findTarget(){
        const range=this.getStats().range, r2=range*range;
        let best=Infinity, bestE=null;
        forEachEnemyNearCircle(this.x, this.y, range, (e)=>{
          const d2 = (e.x-this.x)*(e.x-this.x) + (e.y-this.y)*(e.y-this.y);
          if (d2<=r2 && d2<best){ best=d2; bestE=e; }
        });
        this.target = bestE;
      }
      shoot(){
        if (!this.target) return;
        const note = this.type==='cofrinho' ? 'G5'
                    : this.type==='freela' ? 'C4'
                    : this.type==='guarda_chuva' ? 'A3'
                    : 'B5';
        playSound('shoot', note);
        gameState.projectiles.push(new Projectile(this.x, this.y, this.target, this));
      }
      draw(){
        const img=ASSETS.towers[this.type][this.level];
        if (img && img.complete){
          ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.rotation + Math.PI/2);
          const s=TILE_SIZE; ctx.drawImage(img, -s/2, -s/2, s, s); ctx.restore();
        }
      }
      drawRange(){
        ctx.fillStyle='rgba(16,185,129,0.10)'; ctx.strokeStyle='rgba(16,185,129,0.55)'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.getStats().range,0,Math.PI*2); ctx.fill(); ctx.stroke();
      }
    }

    class Projectile {
      constructor(x,y,target,tower){ this.x=x; this.y=y; this.target=target; this.tower=tower; this.stats=tower.getStats(); this.rotation=tower.rotation; }
      update(){
        if (!this.target || this.target.health<=0) return false;
        const dx=this.target.x-this.x, dy=this.target.y-this.y;
        const dist=Math.hypot(dx,dy);
        if (dist < this.stats.projectile.speed){ this.hitTarget(); return false; }
        this.x += (dx/dist)*this.stats.projectile.speed;
        this.y += (dy/dist)*this.stats.projectile.speed;
        this.rotation=Math.atan2(dy,dx);
        return true;
      }
      hitTarget(){
        if (this.stats.splash){
          const r=this.stats.splash, r2=r*r, tx=this.target.x, ty=this.target.y;
          forEachEnemyNearCircle(tx,ty,r,(e)=>{
            const dx=e.x-tx, dy=e.y-ty;
            if (dx*dx+dy*dy<=r2) e.takeDamage(this.stats.damage);
          });
        } else if (this.stats.slow){
          this.target.takeDamage(0);
          this.target.speed = this.target.baseSpeed * this.stats.slow.factor;
          this.target.slowTimer = this.stats.slow.duration;
        } else this.target.takeDamage(this.stats.damage);
      }
      draw(){
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.rotation);
        ctx.fillStyle=this.stats.projectile.color;
        if (this.tower.type==='freela') ctx.fillRect(-5,-1,10,2);
        else { ctx.beginPath(); ctx.arc(0,0,this.stats.projectile.size,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
      }
    }

    class Particle {
      constructor(x, y, angle, speed, color) {
        this.x = x; this.y = y; this.angle = angle; this.speed = speed; this.color = color; this.life = 20;
      }
      update() { this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; this.life--; return this.life > 0; }
      draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill(); }
    }

    // ========= PLACEMENT / MAP =========
    function isNearPath(x,y, extra=0){
      const half = TILE_SIZE/2; const thr = half + extra;
      const path = MAPS[gameState.mapIndex].path;
      for (let i=0;i<path.length-1;i++){
        const a=path[i], b=path[i+1];
        const ax=a.x*TILE_SIZE + TILE_SIZE/2, ay=a.y*TILE_SIZE + TILE_SIZE/2;
        const bx=b.x*TILE_SIZE + TILE_SIZE/2, by=b.y*TILE_SIZE + TILE_SIZE/2;
        if (pointSegmentDistance(x,y,ax,ay,bx,by) <= thr) return true;
      }
      const end = path[path.length-1];
      const rx = end.x*TILE_SIZE - TILE_SIZE, ry = end.y*TILE_SIZE;
      const rw = TILE_SIZE, rh = TILE_SIZE*2;
      if (x>=rx-8 && x<=rx+rw+8 && y>=ry-8 && y<=ry+rh+8) return true;
      return false;
    }
    function isCollidingTower(x,y){
      for (let i=0;i<gameState.towers.length;i++){
        const t=gameState.towers[i]; if (Math.hypot(t.x-x, t.y-y) < TILE_SIZE-4) return true;
      }
      return false;
    }
    function withinBounds(x,y){
      const m=TOWER_RADIUS+2; return x>=m && x<=canvas.width-m && y>=m && y<=canvas.height-m;
    }
    function canPlaceTower(x,y){ if (!withinBounds(x,y)) return false; if (isNearPath(x,y, TOWER_RADIUS-2)) return false; if (isCollidingTower(x,y)) return false; return true; }

    // ========= INIT =========
    function init(){
      showModal('Carregando...', 'Organizando as finan√ßas...', '', ()=>{});
      defineAssets();
      preloadAssets(()=>{
        setupEventListeners();
        loadGame();
        renderBackground();
        showDifficultySelection();
        gameLoop();
      });
    }

    function gameLoop(){ for (let i=0;i<gameState.gameSpeed;i++) update(); draw(); requestAnimationFrame(gameLoop); }

    function update(){
      if (gameState.status!=='PLAYING') return;

      // Spawner
      if (gameState.waveInProgress){
        if (gameState.spawnTimer>0) gameState.spawnTimer--;
        else {
          const part = gameState.currentWave.enemies[gameState.spawnIndex];
          if (!part) {
            gameState.spawnIndex = gameState.currentWave.enemies.length;
          } else if (part.spawned < part.count){
            gameState.enemies.push(new Enemy(part.type));
            part.spawned++; gameState.spawnTimer = part.delay;
            gameState.spawnedEnemies++;
          } else {
            gameState.spawnIndex++;
          }
        }
      }

      // move enemies
      resetGrid();
      const survivorsE=[];
      for (let i=0;i<gameState.enemies.length;i++){
        const e=gameState.enemies[i]; const alive = e.update(); if (!alive) continue;
        if (e.health>0 && e.pathIndex < MAPS[gameState.mapIndex].path.length-1){ survivorsE.push(e); addEnemyToGrid(e); }
      }
      gameState.enemies = survivorsE;

      // towers
      for (let i=0;i<gameState.towers.length;i++) gameState.towers[i].update();

      // projectiles
      const survivorsP=[];
      for (let i=0;i<gameState.projectiles.length;i++){ const p=gameState.projectiles[i]; if (p.update()) survivorsP.push(p); }
      gameState.projectiles = survivorsP;
      if (gameState.projectiles.length > MAX_PROJECTILES) gameState.projectiles = gameState.projectiles.slice(-MAX_PROJECTILES);

      updateUI();
      if (gameState.totalEnemiesToSpawn > 0) {
        progressFill.style.width = `${(gameState.spawnedEnemies / gameState.totalEnemiesToSpawn) * 100}%`;
      }

      // end of wave
      if (gameState.waveInProgress && gameState.enemies.length===0 && gameState.spawnIndex >= gameState.currentWave.enemies.length){
        endWave();
      }

      if (gameState.health<=0){
        changeStatus('GAMEOVER');
        showModal('Fim de Jogo','A ansiedade venceu. Respira, recalcula e tenta de novo.','Recome√ßar', showDifficultySelection, true);
      }
    }

    function draw(){
      ctx.drawImage(bgCanvas, 0, 0);
      drawMapPath();
      if (gameState.selectedTowerToPlace) drawPlacementPreview();
      for (let i=0;i<gameState.towers.length;i++) gameState.towers[i].draw();
      if (gameState.selectedPlacedTower){
        gameState.selectedPlacedTower.drawRange();
        ctx.strokeStyle='#3b82f6'; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(gameState.selectedPlacedTower.x, gameState.selectedPlacedTower.y, TOWER_RADIUS, 0, Math.PI*2); ctx.stroke();
      }
      for (let i=0;i<gameState.enemies.length;i++) gameState.enemies[i].draw();
      for (let i=0;i<gameState.projectiles.length;i++) gameState.projectiles[i].draw();
      if (gameState.status==='PAUSED') drawPauseOverlay();
    }

    function drawPauseOverlay(){
      ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font='bold 48px Inter, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('JOGO PAUSADO', canvas.width/2, canvas.height/2);
    }

    function drawMapPath() {
      const path = MAPS[gameState.mapIndex].path;
      const style = PATH_STYLES[gameState.mapIndex] || PATH_STYLES.default;
      const px = p => p.x * TILE_SIZE + TILE_SIZE / 2;
      const py = p => p.y * TILE_SIZE + TILE_SIZE / 2;
      ctx.save();
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      if (style.glow > 0) { ctx.shadowBlur = style.glow; ctx.shadowColor = style.inner; }
      ctx.strokeStyle = style.base; ctx.lineWidth = TILE_SIZE + 6; ctx.beginPath();
      ctx.moveTo(px(path[0]), py(path[0])); for (let i = 1; i < path.length; i++) ctx.lineTo(px(path[i]), py(path[i])); ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = style.inner; ctx.lineWidth = TILE_SIZE - 8; ctx.beginPath();
      ctx.moveTo(px(path[0]), py(path[0])); for (let i = 1; i < path.length; i++) ctx.lineTo(px(path[i]), py(path[i])); ctx.stroke();
      if (style.arrows) drawPathArrows(path, style.arrowColor || style.inner, 100, 10);
      ctx.restore();

      // "Goal" drawer (cofre)
      const endPoint = path[path.length - 1];
      ctx.fillStyle = '#78350f';
      ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE, endPoint.y * TILE_SIZE, TILE_SIZE, TILE_SIZE * 2);
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE + 5, endPoint.y * TILE_SIZE + 5, TILE_SIZE - 10, 10);
      ctx.fillStyle = '#f3f4f6';
      ctx.beginPath();
      ctx.arc(endPoint.x * TILE_SIZE - TILE_SIZE / 2, endPoint.y * TILE_SIZE + 25, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawPathArrows(path, color = 'rgba(255,255,255,0.85)', spacing = 90, size = 9) {
      const cx = p => p.x * TILE_SIZE + TILE_SIZE / 2;
      const cy = p => p.y * TILE_SIZE + TILE_SIZE / 2;
      ctx.save(); ctx.fillStyle = color;
      for (let i = 0; i < path.length - 1; i++) {
        const x1 = cx(path[i]), y1 = cy(path[i]);
        const x2 = cx(path[i + 1]), y2 = cy(path[i + 1]);
        const dx = x2 - x1, dy = y2 - y1; const len = Math.hypot(dx, dy); if (len === 0) continue;
        const step = spacing; const ux = dx / len, uy = dy / len;
        for (let s = step * 0.5; s < len; s += step) {
          const ax = x1 + ux * s; const ay = y1 + uy * s; const ang = Math.atan2(dy, dx);
          ctx.save(); ctx.translate(ax, ay); ctx.rotate(ang);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-size, size * 0.6); ctx.lineTo(-size, -size * 0.6); ctx.closePath(); ctx.fill();
          ctx.restore();
        }
      }
      ctx.restore();
    }

    function drawPlacementPreview(){
      const gx = Math.floor(gameState.mouse.x/TILE_SIZE)*TILE_SIZE + TILE_SIZE/2;
      const gy = Math.floor(gameState.mouse.y/TILE_SIZE)*TILE_SIZE + TILE_SIZE/2;
      const can = canPlaceTower(gx, gy);
      ctx.fillStyle = can ? 'rgba(34,197,94,0.18)' : 'rgba(239,68,68,0.18)';
      ctx.strokeStyle = can ? 'rgba(34,197,94,0.60)' : 'rgba(239,68,68,0.60)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(gx, gy, TOWER_RADIUS+2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      const spec = TOWER_SPECS[gameState.selectedTowerToPlace];
      ctx.beginPath(); ctx.arc(gx, gy, spec.upgrades[0].range, 0, Math.PI*2);
      ctx.strokeStyle='rgba(16,185,129,0.25)'; ctx.stroke();
    }

    // ========= WAVE CONTROL =========
    function startWave(){
      if (gameState.waveEndTimer){ clearInterval(gameState.waveEndTimer); gameState.waveEndTimer=null; }
      if (gameState.status!=='PLAYING' || gameState.waveInProgress) return;
      gameState.wave++; gameState.waveInProgress=true;
      startWaveBtn.disabled=true; startWaveBtn.textContent=`ETAPA ${gameState.wave} EM CURSO`; pauseBtn.disabled=false;
      const waveData = JSON.parse(JSON.stringify(WAVES[gameState.wave-1]));
      waveData.enemies.forEach(p=>p.spawned=0);
      gameState.currentWave=waveData; gameState.spawnIndex=0; gameState.spawnTimer=0;
      gameState.totalEnemiesToSpawn = waveData.enemies.reduce((sum, p) => sum + p.count, 0);
      gameState.spawnedEnemies = 0;
    }

    function endWave(){
      gameState.waveInProgress=false; startWaveBtn.disabled=false; pauseBtn.disabled=true;
      gameState.staples += 100 + gameState.wave*10;
      saveGame();

      if (gameState.wave >= WAVES.length){
        changeStatus('VICTORY');
        showModal('Voc√™ Venceu!','Voc√™ atravessou o labirinto dos boletos e alcan√ßou a aposentadoria tranquila. üèñÔ∏è','Jogar Novamente', showDifficultySelection, true);
      } else if (gameState.wave % 5 === 0 && gameState.mapIndex < MAPS.length-1){
        let refund=0; gameState.towers.forEach(t=>{ refund += getTowerValue(t); });
        gameState.staples += refund; gameState.towers=[]; deselectAll();
        const oldIdx=gameState.mapIndex; gameState.mapIndex++;
        const newTowers = getNewUnlocks(oldIdx, gameState.mapIndex);
        const bossName = STAGE_BOSSES[gameState.mapIndex-1] || 'Novo Chefe';
        let text = `Nova fase da vida: ${MAPS[gameState.mapIndex].name}.\nSuas constru√ß√µes foram vendidas pelo valor de revenda.`;
        if (newTowers.length) text += `\n\nFerramentas desbloqueadas:\n${newTowers.map(t=>TOWER_SPECS[t].name).join('\n')}`;
        text += `\n\nRumores: o pr√≥ximo chefe √© **${bossName}**. Prepare o bolso.`;
        populateTowerShop(); renderBackground();
        changeStatus('LEVEL_TRANSITION');
        showModal('Nova Etapa!', text, 'Continuar', ()=>{ changeStatus('PLAYING'); startWaveEndTimer(); });
      } else startWaveEndTimer();
    }

    function startWaveEndTimer(){
      gameState.waveEndCountdown=10;
      startWaveBtn.textContent=`PR√ìXIMA ETAPA EM ${gameState.waveEndCountdown}`;
      gameState.waveEndTimer=setInterval(updateWaveEndTimer,1000);
    }
    function updateWaveEndTimer(){
      gameState.waveEndCountdown--;
      startWaveBtn.textContent=`PR√ìXIMA ETAPA EM ${gameState.waveEndCountdown}`;
      if (gameState.waveEndCountdown<=0) startWave();
    }

    // ========= GAME FLOW =========
    function startGame(diff){
      gameState.difficulty = DIFFICULTY_SETTINGS[diff];
      resetGame();
      if (!audio.ready) initAudio();
    }
    function resetGame(){
      if (gameState.waveEndTimer){ clearInterval(gameState.waveEndTimer); gameState.waveEndTimer=null; }
      gameState.staples=gameState.difficulty.startingStaples;
      gameState.health=gameState.difficulty.startingHealth;
      gameState.wave=0; gameState.mapIndex=0;
      gameState.enemies=[]; gameState.towers=[]; gameState.projectiles=[];
      gameState.waveInProgress=false; deselectAll();
      startWaveBtn.disabled=false; startWaveBtn.textContent='INICIAR ETAPA'; pauseBtn.disabled=true;
      populateTowerShop(); renderBackground(); changeStatus('PLAYING');
      localStorage.removeItem('billBattleSave');
    }

    function initAudio(){
      if (audio.ready) return;
      Tone.start();
      audio.synths.shoot = new Tone.Synth({ volume:-15, oscillator:{type:'square'}, envelope:{attack:0.01, decay:0.1, sustain:0.1, release:0.1} }).toDestination();
      audio.synths.place = new Tone.Synth({ volume:-10, oscillator:{type:'sine'}, envelope:{attack:0.01, decay:0.2, sustain:0, release:0.2} }).toDestination();
      audio.synths.upgrade= new Tone.PluckSynth({ volume:-5 }).toDestination();
      audio.synths.error = new Tone.Synth({ volume:-10, oscillator:{type:'triangle'}, envelope:{attack:0.01, decay:0.3, sustain:0, release:0.1} }).toDestination();
      audio.synths.hit = new Tone.MembraneSynth({ volume:-20, pitchDecay:0.01, octaves:2, envelope:{attack:0.001, decay:0.1, sustain:0} }).toDestination();
      audio.music = new Tone.Loop(time=>{
        audio.synths.place.triggerAttackRelease("C2","8n",time);
        audio.synths.place.triggerAttackRelease("G2","8n",time+Tone.Time("8n"));
      },"1n").start(0);
      Tone.Transport.start(); audio.ready=true;
    }
    function playSound(synthName,note,duration='16n'){
      if (!audio.ready || audio.muted) return;
      const now=Tone.now();
      if (synthName==='hit' && now < audio.lastHitSoundTime + audio.hitSoundInterval) return;
      if (synthName==='shoot' && now < audio.lastShootSoundTime + audio.shootSoundInterval) return;
      if (synthName==='hit') audio.lastHitSoundTime = now;
      if (synthName==='shoot') audio.lastShootSoundTime = now;
      if (audio.synths[synthName]) audio.synths[synthName].triggerAttackRelease(note,duration);
    }

    // ========= ECONOMIA =========
    function getTowerCost(type, level=0){
      const spec=TOWER_SPECS[type];
      if (level===0) return Math.floor(spec.baseCost * gameState.difficulty.towerCostMultiplier);
      return Math.floor(spec.upgrades[level-1].cost * gameState.difficulty.towerCostMultiplier);
    }
    function getTowerValue(tower){
      let total=getTowerCost(tower.type,0);
      for (let i=0;i<tower.level;i++) total+=getTowerCost(tower.type,i+1);
      return total;
    }

    // ========= UI =========
    function updateUI(){
      staplesEl.textContent=gameState.staples;
      healthEl.textContent=gameState.health;
      waveEl.textContent=gameState.wave;
      if (gameState.selectedPlacedTower){
        const t=gameState.selectedPlacedTower, stats=t.getStats(), next=t.spec.upgrades[t.level+1];
        upgradePanelEl.classList.remove('hidden');
        upgradeTowerNameEl.textContent=t.spec.name;
        upgradeTowerLevelEl.textContent=t.level+1;
        upgradeTowerDamageEl.textContent=stats.damage || 'N/A';
        upgradeTowerRangeEl.textContent=stats.range;
        if (next){ const upc=getTowerCost(t.type, t.level+1);
          upgradeBtn.disabled = gameState.staples < upc;
          upgradeBtn.textContent = `Upgrade (üí∞ ${upc})`;
        } else { upgradeBtn.textContent='N√≠vel M√°ximo'; upgradeBtn.disabled=true; }
        const sellValue = Math.floor(getTowerValue(t)*0.75);
        sellBtn.textContent=`Vender (üí∞ ${sellValue})`;
      } else upgradePanelEl.classList.add('hidden');
    }

    function populateTowerShop(){
      towerSelectionEl.innerHTML='';
      for (const key in TOWER_SPECS){
        const spec=TOWER_SPECS[key];
        if (gameState.mapIndex >= spec.unlocksAtMap){
          const card=document.createElement('div');
          card.className='tower-card bg-gray-50 p-2 rounded-lg cursor-pointer flex items-center gap-4';
          card.dataset.towerType=key;
          const cost=gameState.difficulty?getTowerCost(key):spec.baseCost;
          card.innerHTML=`
            <div class="tower-card-img" style="background-image:url('${ASSETS.towers[key][0].src}')"></div>
            <div><h3 class="font-semibold text-gray-800">${spec.name}</h3>
            <p class="font-bold text-gray-600">üí∞ ${cost}</p></div>`;
          card.addEventListener('mouseover', () => {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            const stats = spec.upgrades[0];
            tooltip.innerHTML = `Dano: ${stats.damage || 'N/A'}<br>Alcance: ${stats.range}<br>Taxa de Fogo: ${stats.fireRate}`;
            card.appendChild(tooltip);
            tooltip.style.display = 'block';
            tooltip.style.left = '100%';
            tooltip.style.top = '0';
          });
          card.addEventListener('mouseout', () => {
            const tooltip = card.querySelector('.tooltip');
            if (tooltip) tooltip.remove();
          });
          towerSelectionEl.appendChild(card);
        }
      }
    }
    function getNewUnlocks(oldIdx,newIdx){
      const arr=[]; for (const k in TOWER_SPECS){ const s=TOWER_SPECS[k]; if (s.unlocksAtMap>oldIdx && s.unlocksAtMap<=newIdx) arr.push(k); } return arr;
    }

    function showModal(title,text,btnText,callback, showRestart=false){
      const modalTitle=document.getElementById('modal-title');
      const modalContent=document.getElementById('modal-content');
      const modalButtons=document.getElementById('modal-buttons');
      modalTitle.textContent=title; modalContent.innerHTML=text; modalButtons.innerHTML='';
      if (btnText && callback){
        const btn=document.createElement('button');
        btn.className='bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-xl';
        btn.textContent=btnText; btn.onclick=callback; modalButtons.appendChild(btn);
      }
      if (showRestart) {
        const restartBtn = document.createElement('button');
        restartBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2';
        restartBtn.textContent = 'Reiniciar';
        restartBtn.onclick = () => { resetGame(); changeStatus('PLAYING'); };
        modalButtons.appendChild(restartBtn);
      }
      document.getElementById('modal').classList.remove('modal-hidden');
    }

    function showDifficultySelection(){
      const t=document.getElementById('modal-title');
      const c=document.getElementById('modal-content');
      const b=document.getElementById('modal-buttons');
      t.textContent='Batalha dos Boletos';
      c.innerHTML='Selecione a dificuldade e enfrente a vida real financeira. <br><br><small>Dica: Cofrinho + Planilha seguram bem as primeiras etapas.</small>';
      b.innerHTML=`
        <button id="easy-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">F√°cil</button>
        <button id="normal-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">Normal</button>
        <button id="hard-btn" class="bg-rose-600 hover:bg-rose-700 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">Dif√≠cil</button>`;
      document.getElementById('easy-btn').onclick = ()=>startGame('facil');
      document.getElementById('normal-btn').onclick = ()=>startGame('normal');
      document.getElementById('hard-btn').onclick = ()=>startGame('dificil');
      document.getElementById('modal').classList.remove('modal-hidden');
    }

    function changeStatus(s){
      gameState.status=s;
      if (!['LEVEL_TRANSITION','GAMEOVER','VICTORY','START'].includes(s)){
        document.getElementById('modal').classList.add('modal-hidden');
      }
    }

    function deselectAll(){
      gameState.selectedTowerToPlace=null; gameState.selectedPlacedTower=null;
      document.querySelectorAll('.tower-card.selected').forEach(c=>c.classList.remove('selected'));
      updateUI();
    }

    function setupEventListeners(){
      towerSelectionEl.addEventListener('click', e=>{
        const card=e.target.closest('.tower-card'); if (!card) return;
        const type=card.dataset.towerType; const cost=getTowerCost(type);
        if (gameState.staples >= cost){ deselectAll(); gameState.selectedTowerToPlace=type; card.classList.add('selected'); }
      });
      canvas.addEventListener('mousemove', e=>{
        const r=canvas.getBoundingClientRect(); gameState.mouse.x=e.clientX-r.left; gameState.mouse.y=e.clientY-r.top;
      });
      canvas.addEventListener('click', ()=>{
        if (gameState.status!=='PLAYING') return;
        const gx=Math.floor(gameState.mouse.x/TILE_SIZE)*TILE_SIZE + TILE_SIZE/2;
        const gy=Math.floor(gameState.mouse.y/TILE_SIZE)*TILE_SIZE + TILE_SIZE/2;
        if (gameState.selectedTowerToPlace){
          const cost=getTowerCost(gameState.selectedTowerToPlace);
          if (gameState.staples >= cost && canPlaceTower(gx,gy)){
            gameState.towers.push(new Tower(gx,gy,gameState.selectedTowerToPlace));
            gameState.staples -= cost; playSound('place','C5'); deselectAll();
          } else if (!canPlaceTower(gx,gy)){ playSound('error','C3','16n'); }
        } else {
          let clicked=null;
          for (const t of gameState.towers){ if (Math.hypot(t.x-gx, t.y-gy) < TOWER_RADIUS){ clicked=t; break; } }
          gameState.selectedPlacedTower=clicked; updateUI();
        }
      });
      upgradeBtn.addEventListener('click', ()=>{
        const t=gameState.selectedPlacedTower; if (!t) return;
        const next=t.spec.upgrades[t.level+1]; if (!next) return;
        const cost=getTowerCost(t.type, t.level+1);
        if (gameState.staples >= cost){ gameState.staples -= cost; t.level++; playSound('upgrade','E6'); updateUI(); }
      });
      sellBtn.addEventListener('click', ()=>{
        const t=gameState.selectedPlacedTower; if (!t) return;
        const sellValue=Math.floor(getTowerValue(t)*0.75);
        gameState.staples += sellValue;
        gameState.towers = gameState.towers.filter(x=>x!==t);
        playSound('place','A4'); deselectAll();
      });
      startWaveBtn.addEventListener('click', startWave);
      pauseBtn.addEventListener('click', ()=>{
        if (gameState.status==='PLAYING'){ changeStatus('PAUSED'); pauseBtn.innerHTML='‚ñ∂Ô∏è'; }
        else if (gameState.status==='PAUSED'){ changeStatus('PLAYING'); pauseBtn.innerHTML='‚è∏Ô∏è'; }
        playSound('place','E5','32n');
      });
      speedBtn.addEventListener('click', ()=>{
        gameState.speedIndex=(gameState.speedIndex+1)%SPEED_MULTIPLIERS.length;
        gameState.gameSpeed=SPEED_MULTIPLIERS[gameState.speedIndex];
        speedBtn.textContent=`${gameState.gameSpeed}x`;
        playSound('place','G5','32n');
      });
      muteBtn.addEventListener('click', ()=>{
        audio.muted=!audio.muted; muteBtn.textContent=audio.muted?'üîá':'üîä';
        if (audio.muted) Tone.Transport.pause(); else Tone.Transport.start();
      });
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.touches[0];
        const r = canvas.getBoundingClientRect();
        gameState.mouse.x = touch.clientX - r.left;
        gameState.mouse.y = touch.clientY - r.top;
        canvas.dispatchEvent(new MouseEvent('click', { clientX: touch.clientX, clientY: touch.clientY }));
      });
      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const touch = e.touches[0];
        const r = canvas.getBoundingClientRect();
        gameState.mouse.x = touch.clientX - r.left;
        gameState.mouse.y = touch.clientY - r.top;
      });
    }

    function saveGame() {
      localStorage.setItem('billBattleSave', JSON.stringify({
        staples: gameState.staples,
        health: gameState.health,
        wave: gameState.wave,
        mapIndex: gameState.mapIndex,
        towers: gameState.towers.map(t => ({x: t.x, y: t.y, type: t.type, level: t.level})),
        difficulty: gameState.difficulty
      }));
    }
    function loadGame() {
      const saved = localStorage.getItem('billBattleSave');
      if (saved) {
        const data = JSON.parse(saved);
        gameState.staples = data.staples;
        gameState.health = data.health;
        gameState.wave = data.wave;
        gameState.mapIndex = data.mapIndex;
        gameState.towers = data.towers.map(t => {
          const tower = new Tower(t.x, t.y, t.type);
          tower.level = t.level;
          return tower;
        });
        gameState.difficulty = data.difficulty;
        populateTowerShop();
        renderBackground();
        changeStatus('PLAYING');
      }
    }

    // ========= BACKGROUNDS =========
    function renderBackground(){
      bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
      const idx = gameState.mapIndex % MAPS.length;
      const drawer = [
        drawKidsRoom,
        drawNeighborhood,
        drawCampus,
        drawApartmentTiles,
        drawDowntown,
        drawCoupleHome,
        drawNursery,
        drawSuburb,
        drawBearMarket,
        drawBeach
      ][idx] || drawKidsRoom;
      drawer(bgCtx, bgCanvas.width, bgCanvas.height);
    }

    function drawKidsRoom(ctx,w,h){
      const g=ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'#fde68a'); g.addColorStop(1,'#fcd34d');
      ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
      // toys
      ctx.fillStyle='#a78bfa'; ctx.beginPath(); ctx.arc(100,120,18,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#f87171'; ctx.fillRect(160,80,36,18);
      ctx.fillStyle='#34d399'; ctx.fillRect(w-180,h-120,60,18);
    }
    function drawNeighborhood(ctx,w,h){
      ctx.fillStyle='#e2e8f0'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#cbd5e1'; ctx.fillRect(0,h/2-40,w,80);
      ctx.setLineDash([20,20]); ctx.strokeStyle='#f8fafc'; ctx.lineWidth=6;
      ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#84cc16'; ctx.fillRect(0,h/2+40,w,40); ctx.fillRect(0,h/2-80,w,40);
    }
    function drawCampus(ctx,w,h){
      ctx.fillStyle='#dcfce7'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#86efac'; ctx.fillRect(0,h*0.6,w,h*0.4);
      ctx.fillStyle='#a3a3a3'; ctx.fillRect(0,h*0.45,w,30);
    }
    function drawApartmentTiles(ctx,w,h){
      ctx.fillStyle='#f5f5f5'; ctx.fillRect(0,0,w,h);
      ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1;
      for(let x=0;x<w;x+=48){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
      for(let y=0;y<h;y+=48){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    }
    function drawDowntown(ctx,w,h){
      const g=ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'#0ea5e9'); g.addColorStop(1,'#38bdf8'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#1f2937'; for(let i=0;i<8;i++){ const x=50+i*100; ctx.fillRect(x,h-140,60,140); }
      ctx.fillStyle='#f8fafc'; for(let i=0;i<8;i++){ for(let y=h-130;y<h-20;y+=20) ctx.fillRect(60+i*100,y,6,10); }
    }
    function drawCoupleHome(ctx,w,h){
      ctx.fillStyle='#fef2f2'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#fecdd3'; ctx.fillRect(0,h-100,w,100);
      ctx.fillStyle='#fca5a5'; ctx.beginPath(); ctx.arc(120,120,18,0,Math.PI*2); ctx.fill();
    }
    function drawNursery(ctx,w,h){
      ctx.fillStyle='#ecfeff'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#bae6fd'; ctx.fillRect(0,h-120,w,120);
      ctx.fillStyle='#fde68a'; ctx.beginPath(); ctx.arc(200,100,18,0,Math.PI*2); ctx.fill();
    }
    function drawSuburb(ctx,w,h){
      ctx.fillStyle='#e5e7eb'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle='#94a3b8'; for(let i=0;i<w;i+=120) ctx.fillRect(i,h-80,100,80);
      ctx.fillStyle='#84cc16'; ctx.fillRect(0,h-20,w,20);
    }
    function drawBearMarket(ctx,w,h){
      ctx.fillStyle='#111827'; ctx.fillRect(0,0,w,h);
      ctx.strokeStyle='#f87171'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(0,h*0.7);
      for(let x=0;x<w;x+=40){
        const y=h*0.7 + Math.sin(x*0.05)*30 - x*0.1;
        ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    function drawBeach(ctx,w,h){
      ctx.fillStyle='#93c5fd'; ctx.fillRect(0,0,w,h*0.4);
      ctx.fillStyle='#60a5fa'; ctx.fillRect(0,h*0.35,w,10);
      ctx.fillStyle='#fde68a'; ctx.fillRect(0,h*0.4,w,h*0.6);
    }

    // ========= BOOT =========
    init();
  </script>
</body>
</html>
